{
  "version": 3,
  "sources": ["../components/view.ts", "../components/forEach.ts", "../index.ts", "demo.ts"],
  "sourcesContent": ["import { input, S, state, text } from \"../index\";\nimport { ariaRole, C, E, Style } from \"./utilTypes\";\n\nexport type allView = view | scrollView | text | input | HTMLElement | Comment;\nexport class baseNode<T extends Node> {\n  constructor(public dom: T) { }\n}\ntype tss_events = { [k in keyof HTMLElementEventMap]?: S<HTMLElementEventMap[k]>; };\ntype tss_exist<T> = T extends void ? never : T;\nfunction keyboardAccessible(dom: HTMLElement) {\n  dom.addEventListener(\"keydown\", () => dom.click());\n}\nexport class baseView<T extends E> extends baseNode<T> {\n  style: CSSStyleDeclaration;\n  constructor(dom: T) {\n    super(dom);\n    this.style = this.dom.style;\n  }\n  addStyle(style: Style = {}): this {\n    Object.assign(this.dom.style, style);\n    return this;\n  }\n  setAttr(attr: {\n    [key: string]: string;\n  } = {}): this {\n    for (const k in attr) {\n      this.dom.setAttribute(k, attr[k]);\n    }\n    return this;\n  }\n  private _events: tss_events = {};\n  /** Better accessibility support, adding tabindex to make elements focusable, and triggering events when the Enter key is pressed. */\n  onClick() {\n    keyboardAccessible(this.dom);\n    this.dom.setAttribute(\"tabindex\", \"0\");\n    return this.on(\"click\");\n  }\n  on<T extends keyof tss_events>(event: T) {\n    if (event in this._events) return this._events[event]!.updates();\n    let s = state<HTMLElementEventMap[T]>() as tss_exist<tss_events[T]>;\n    this.dom.addEventListener(event, (e) => { s.update(e); });\n    this._events[event] = s;\n    return s.updates();\n  }\n}\nclass view extends baseView<HTMLDivElement> {\n  _scrollListener?: view[];\n  constructor(...children: (allView | string)[]) {\n    super(document.createElement('div'));\n    for (const ele of children) {\n      if (typeof ele == 'string') {\n        this.dom.appendChild(document.createTextNode(ele));\n      } else if (ele instanceof Node) {\n        this.dom.appendChild(ele);\n      } else {\n        if (ele instanceof view && ele._scrollListener) {\n          if (!this._scrollListener) this._scrollListener = [ele];\n          else this._scrollListener.push(ele);\n        }\n        this.dom.appendChild(ele.dom);\n      }\n    }\n  }\n  role(v: ariaRole): this {\n    this.dom.role = v;\n    return this;\n  }\n  _whenScroll(s: scrollView) {\n    this._scrollListener?.forEach(n => n._whenScroll(s));\n  }\n}\nasync function whenScroll(s: scrollView) {\n  for await (const _ of s.on(\"scroll\")) {\n    s._whenScroll(s);\n  }\n}\nclass scrollView extends view {\n  constructor(...children: (allView | string)[]) {\n    super(...children);\n    this.style.height = '100%';\n    this.style.width = '100%';\n    this.style.overflow = 'auto';\n    if (this._scrollListener != void 0)\n      whenScroll(this);\n  }\n  get scrollTop() {\n    return this.dom.scrollTop;\n  }\n  get scrollLeft() {\n    return this.dom.scrollLeft;\n  }\n  get scrollHeight() {\n    return this.dom.scrollHeight;\n  }\n  get scrollWidth() {\n    return this.dom.scrollWidth;\n  }\n}\nexport function View(...children: (allView | string)[]) {\n  return new view(...children);\n}\nexport function ScrollView(...children: (allView | string)[]) {\n  return new scrollView(...children);\n}\nexport { view, scrollView };", "import { allView, baseNode, S } from \"../index\";\nimport { C } from \"./utilTypes\";\n\nfunction find<T>(\n  arr: readonly T[],\n  target: T,\n): number {\n  let left = 0;\n  let right = arr.length;\n\n  while (left < right) {\n    const mid = (left + right) >> 1;\n    if (arr[mid] == target) {\n      return mid;\n    } else if (arr[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n\n  return left;\n}\nfunction getDom<N extends C>(v: N): Node {\n  if (v instanceof Node) return v;\n  else return v.dom;\n}\nasync function listUpdate<T, N extends C>(d: Comment, list: S<T[]>, f: (item: T) => N, nodes: N[]) {\n  let mapIdx = new Map<T, number>();\n  for await (const l of list.updates()) {\n    let start = l.length;\n    for (let i = 0, len = l.length; i < len; i++)\n      if (mapIdx.get(l[i]) != i) {\n        start = i;\n        break;\n      }\n\n    let end = l.length;\n    for (let i = l.length, j = nodes.length; i--;)\n      if (mapIdx.get(l[i]) != j-- || i < start) {\n        end = i + 1;\n        break;\n      }\n\n    let seq: number[] = [];\n    let pos: number[] = [];\n    for (let i = start; i < end; i++) {\n      const v = mapIdx.get(l[i]);\n      if (v == void 0) continue;\n      if (v < 0) throw new Error('Duplicate elements');\n      mapIdx.set(l[i], -v - 1);\n\n      let n = find(seq, v);\n      seq[n] = v;\n      pos[i] = n;\n    }\n    for (let i = pos.length, len = seq.length - 1; i--;) {\n      if (pos[i] == len) {\n        const _v = mapIdx.get(l[i])!;\n        const v = _v < 0 ? -_v - 1 : _v;\n        seq[len] = v;\n        len--;\n      }\n    }\n    let parentDom = d.parentNode;\n    if (!parentDom) {\n      console.warn('no parent node');\n      break;\n    };\n    debugger;\n    for (const key of mapIdx.keys()) {\n      const i = mapIdx.get(key)!;\n      if (i >= start) {\n        mapIdx.delete(key);\n        const n = nodes[i];\n        parentDom.removeChild(getDom(n));\n      }\n    }\n    let newNodes: N[] = [];\n    let j = 0, nextI = seq.length > 0 ? seq[j] : end;\n    let next = seq.length > 0 ? getDom(nodes[seq[j]]) : d;\n    for (let i = start; i < end; i++) {\n      const old = mapIdx.get(l[i]);\n      if (old == void 0) {\n        const n = f(l[i]);\n        newNodes[i - start] = n;\n        parentDom.insertBefore(getDom(n), next);\n      } else {\n        const k = -old - 1;\n        if (k == nextI) {\n          j++;\n          newNodes[i - start] = nodes[k];\n          if (j < seq.length) {\n            nextI = seq[j];\n            next = getDom(nodes[seq[j]]);\n          } else {\n            nextI = end;\n            next = d;\n          }\n        } else {\n          const n = nodes[k];\n          newNodes[i - start] = n;\n          parentDom.insertBefore(getDom(n), next);\n        }\n      }\n    }\n    let len = l.length;\n    for (let i = start; i < len; i++) {\n      mapIdx.set(l[i], i);\n    }\n    debugger;\n    nodes.splice(start, (l.length - end + nodes.length) - start, ...newNodes);\n  }\n}\n\n/**\n * List elements cannot be duplicated!\n */\nexport function _forEach<T, N extends C>(list: S<T[]>, f: (item: T) => N, nodes: N[] = []) {\n  let dom = document.createComment(\"\");\n  listUpdate(dom, list, f, nodes);\n  return dom;\n}\nexport function forEach<T>(list: S<T[]>, f: (item: T) => allView) {\n  return _forEach<T, allView>(list, f);\n}", "if (typeof Promise.withResolvers !== \"function\") {\n  Promise.withResolvers = function <T>(): PromiseWithResolvers<T> {\n    let resolve, reject;\n    const promise = new Promise<T>((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n    // @ts-ignore\n    return { promise, resolve, reject };\n  };\n}\n\nclass S<T> {\n  #resolve?: (v: T) => void;\n  #currentPromise?: Promise<T>;\n\n  async *updates() {\n    while (true) {\n      let promise = this.#currentPromise;\n      if (!promise) {\n        let { promise, resolve } = Promise.withResolvers<T>();\n        this.#resolve = resolve;\n        this.#currentPromise = promise;\n        yield await promise;\n      } else {\n        yield await promise;\n      }\n    }\n  }\n\n  update(v: T) {\n    this.#resolve?.(v);\n    this.#currentPromise = void 0;\n  }\n}\n\nexport function state<T>() {\n  return new S<T>();\n}\nexport type { S };\nexport * from \"./components/view\";\nexport * from \"./components/forEach\";\nexport * from \"./components/elements\";", "import { forEach, state, View } from \"../index\";\n// esbuild ./demo.ts --bundle --outfile=./demo.js --minify --sourcemap --format=esm --watch\nconst l = state<string[]>();\n\nlet d = View(\"+\").role(\"button\");\ndocument.body.appendChild(View(\n  forEach(l, (item) => {\n    return View(item);\n  }),\n  d\n).dom);\nlet todoList = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\"];\nfunction shuffleArray(array: any[]) {\n  for (let i = array.length - 1; i > 0; i--) {\n    // Generate a random index between 0 and i\n    let j = Math.floor(Math.random() * (i + 1));\n\n    // Swap elements at indices i and j\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n}\n\nasync function a() {\n  for await (const _ of d.onClick()) {\n    shuffleArray(todoList);\n    todoList.pop();\n    l.update(todoList);\n  }\n}\na();"],
  "mappings": "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",
  "names": ["baseNode", "dom", "keyboardAccessible", "baseView", "style", "attr", "k", "event", "s", "state", "e", "view", "_view", "children", "ele", "v", "n", "View", "children", "view", "find", "arr", "target", "left", "right", "mid", "getDom", "v", "listUpdate", "d", "list", "f", "nodes", "mapIdx", "l", "start", "i", "len", "end", "j", "seq", "pos", "n", "_v", "parentDom", "key", "newNodes", "nextI", "next", "old", "k", "_forEach", "dom", "forEach", "resolve", "reject", "res", "rej", "S", "#resolve", "#currentPromise", "promise", "v", "state", "l", "state", "d", "View", "forEach", "item", "todoList", "shuffleArray", "array", "i", "j", "a", "_"]
}
